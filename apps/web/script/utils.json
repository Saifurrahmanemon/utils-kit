[
  {
    "name": "clsx",
    "dir": "utils",
    "file": {
      "name": "clsx.ts",
      "content": "/**\n * use cases:\n* clsx('btn', 'primary'); // 'btn primary'\n* clsx('btn', { active: true }); // 'btn active'\n* clsx({ 'text-center': true }); // 'text-center'\n* clsx({ 'text-center': false }); // ''\n* clsx({ visible: true }, { hidden: true }); // 'visible hidden'\n* clsx({ visible: true, hidden: true }); // 'visible hidden'\n* clsx({ visible: true, hidden: false, selected: true }); // 'visible selected'\n* clsx('list-item', ['flex', { 'justify-center': true, 'items-center': false }]); // 'list-item flex justify-center'\n* clsx(\n  'container',\n  {\n    'mx-auto': true,\n    'max-w-md': false,\n  },\n  'p-4',\n  { 'bg-white': true },\n  ); // 'container mx-auto p-4 bg-white'\n * clsx({ active: true, disabled: true }, { active: false }); // 'disabled'\n * clsx('btn', () => 'primary'); // 'btn primary'\n * clsx('icon', () => 'icon-arrow-right'); // 'icon icon-arrow-right'\n * clsx(null, false, 'error', undefined, { success: null }, ''); // 'error'\n * clsx('btn', 'btn'); // 'btn'\n * clsx({ 'text-bold': true }, { 'text-bold': true }); // 'text-bold'\n *\n **/\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ClassObj = Record<string, any>;\ntype ClassValue =\n  | ClassArray\n  | ClassObj\n  | Function\n  | string\n  | number\n  | null\n  | boolean\n  | undefined;\nexport type ClassArray = Array<ClassValue>;\n\n/**\n * Concatenates class names and returns a string.\n *\n * @param {Array<ClassValue>} args - An array of class values to concatenate.\n * @return {string} - The concatenated class names.\n */\nexport default function clsx(...args: Array<ClassValue>): string {\n  const classes: Set<string> = new Set();\n\n  function clsxExe(...args: Array<ClassValue>) {\n    args.forEach((arg) => {\n      const argType = typeof arg;\n\n      if (!arg) {\n        return;\n      }\n\n      // check for string and numbers.\n      if (argType === 'string' || argType === 'number') {\n        classes.add(String(arg));\n        return;\n      }\n\n      // check functions.\n      if (argType === 'function') {\n        const result = (arg as Function)();\n        if (!result) {\n          return;\n        }\n\n        classes.add(String(result));\n      }\n\n      // check arrays.\n      if (Array.isArray(arg)) {\n        for (const cls of arg) {\n          clsxExe(cls);\n        }\n\n        return;\n      }\n\n      // check objects.\n      if (argType === 'object') {\n        const objArg = arg as ClassObj;\n        for (const key in objArg) {\n          // use Object.hasOwn()\n          if (Object.prototype.hasOwnProperty.call(objArg, key)) {\n            objArg[key] ? classes.add(key) : classes.delete(key);\n          }\n        }\n\n        return;\n      }\n    });\n  }\n\n  clsxExe(args);\n\n  return Array.from(classes).join(' ');\n}\n"
    }
  },
  {
    "name": "cryptr",
    "dir": "utils",
    "file": {
      "name": "cryptr.ts",
      "content": "import {\n  createCipheriv,\n  createDecipheriv,\n  Encoding,\n  pbkdf2Sync,\n  randomBytes\n} from 'crypto';\n\ninterface CryptrOptions {\n  encoding?: Encoding;\n  pbkdf2Iterations?: number;\n  saltLength?: number;\n}\n\nclass Cryptr {\n  private static readonly ALGORITHM = 'aes-256-gcm';\n  private static readonly IV_LENGTH = 16;\n  private static readonly TAG_LENGTH = 16;\n  private static readonly DEFAULT_ENCODING: Encoding = 'hex';\n  private static readonly DEFAULT_SALT_LENGTH = 64;\n  private static readonly DEFAULT_PBKDF2_ITERATIONS = 390000;\n\n  private readonly encoding: Encoding;\n  private readonly pbkdf2Iterations: number;\n  private readonly saltLength: number;\n  private readonly tagPosition: number;\n  private readonly encryptedPosition: number;\n\n  constructor(\n    private readonly secret: string,\n    options: CryptrOptions = {}\n  ) {\n    this.validateSecret(secret);\n\n    this.encoding = options.encoding ?? Cryptr.DEFAULT_ENCODING;\n    this.pbkdf2Iterations =\n      options.pbkdf2Iterations ?? Cryptr.DEFAULT_PBKDF2_ITERATIONS;\n    this.saltLength = options.saltLength ?? Cryptr.DEFAULT_SALT_LENGTH;\n\n    this.tagPosition = this.saltLength + Cryptr.IV_LENGTH;\n    this.encryptedPosition = this.tagPosition + Cryptr.TAG_LENGTH;\n  }\n\n  private validateSecret(secret: string): void {\n    if (!secret || typeof secret !== 'string') {\n      throw new Error('Cryptr: secret must be a non-0-length string');\n    }\n  }\n\n  private validateValue(value: unknown): asserts value is string | Buffer {\n    if (value == null) {\n      throw new Error('value must not be null or undefined');\n    }\n  }\n\n  private getKey(salt: Buffer): Buffer {\n    return pbkdf2Sync(\n      this.secret,\n      salt,\n      this.pbkdf2Iterations,\n      32, // 32 bytes = 256 bits\n      'sha512'\n    );\n  }\n\n  /**\n   * Encrypts the given value using the provided secret and encryption options.\n   *\n   * @param value - The value to encrypt.\n   * @returns A base64-encoded string representing the encrypted value.\n   */\n  encrypt(value: string | Buffer): string {\n    try {\n      this.validateValue(value);\n\n      const ivBuffer = randomBytes(Cryptr.IV_LENGTH);\n      const saltBuffer = randomBytes(this.saltLength);\n\n      const key = this.getKey(saltBuffer);\n      const cipher = createCipheriv(Cryptr.ALGORITHM, key, ivBuffer);\n      cipher.setAAD(saltBuffer);\n\n      const encryptedBuffer = Buffer.concat([\n        cipher.update(value),\n        cipher.final()\n      ]);\n      const tag = cipher.getAuthTag();\n\n      const encrypted = Buffer.concat([\n        saltBuffer,\n        ivBuffer,\n        tag,\n        encryptedBuffer\n      ]);\n      return encrypted.toString(this.encoding);\n    } catch (error) {\n      throw new Error(`Cryptr encryption failed: ${error}`);\n    }\n  }\n\n  decrypt(value: string): string {\n    try {\n      this.validateValue(value);\n\n      const stringValue = Buffer.from(value, this.encoding);\n\n      const salt = stringValue.subarray(0, this.saltLength);\n      const iv = stringValue.subarray(this.saltLength, this.tagPosition);\n      const tag = stringValue.subarray(\n        this.tagPosition,\n        this.encryptedPosition\n      );\n      const encrypted = stringValue.subarray(this.encryptedPosition);\n\n      const key = this.getKey(salt);\n\n      const decipher = createDecipheriv(Cryptr.ALGORITHM, key, iv);\n      decipher.setAAD(salt);\n      decipher.setAuthTag(tag);\n\n      return decipher.update(encrypted) + decipher.final('utf8');\n    } catch (error) {\n      throw new Error(`Cryptr decryption failed: ${error}`);\n    }\n  }\n}\n\nexport default Cryptr;\n"
    }
  },
  {
    "name": "debounce",
    "dir": "utils",
    "file": {
      "name": "debounce.ts",
      "content": "interface DebouncedFunction extends Function {\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Debounces a function, delaying its execution until after a specified wait time has elapsed\n * since the last invocation.\n *\n * @param func - The function to debounce.\n * @param wait - The wait time in milliseconds.\n * @returns A debounced function with `cancel` and `flush` methods.\n * @throws {Error} If `func` is not a function or `wait` is not a positive number.\n */\n// eslint-disable-next-line no-unused-vars\nexport default function debounce<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number\n): DebouncedFunction {\n  if (typeof func !== 'function') {\n    throw new Error(\n      `The provided argument \"func\"(${typeof func}) must be a function.`\n    );\n  }\n\n  if (typeof wait !== 'number' || isNaN(wait) || wait < 0) {\n    throw new Error(\n      `The provided argument \"wait\"(${typeof wait}) must be a positive number.`\n    );\n  }\n\n  let timeoutId: ReturnType<typeof setTimeout> | undefined;\n  let lastArgs: Parameters<T>;\n  let lastThis: ThisParameterType<T>;\n\n  const clearTimer = () => {\n    clearTimeout(timeoutId);\n    timeoutId = undefined;\n  };\n\n  const invoke = () => {\n    if (!timeoutId) return;\n    clearTimer();\n    func.apply(lastThis, lastArgs);\n  };\n\n  function debounced(this: ThisParameterType<T>, ...args: Parameters<T>) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    lastThis = this;\n    lastArgs = args;\n    clearTimer();\n    timeoutId = setTimeout(invoke, wait);\n  }\n\n  debounced.cancel = clearTimer;\n  debounced.flush = invoke;\n\n  return debounced as DebouncedFunction;\n}\n"
    }
  },
  {
    "name": "deepEqual",
    "dir": "utils",
    "file": {
      "name": "deepEqual.ts",
      "content": "function getType(input: any): string {\n  const lowerCaseTheFirstLetter = (str: string) =>\n    str[0].toLowerCase() + str.slice(1);\n  const type = typeof input;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return lowerCaseTheFirstLetter(\n    Object.prototype.toString.call(input).replace(/^\\[object (\\S+)\\]$/, '$1')\n  );\n}\n\n/**\n * Compares two values recursively to check if they are deeply equal.\n *\n * @param {unknown} inputOne - The first value to compare.\n * @param {unknown} inputTwo - The second value to compare.\n * @return {boolean} Returns true if the values are deeply equal, false otherwise.\n *\n *  * @note\n * - This function does not handle comparing functions.\n * - This function does not handle circular objects.\n * - This function only compares enumerable properties of objects.\n * - This function compares objects and arrays, but it does not handle other types such as strings, numbers, booleans, or null.\n */\nexport default function deepEqual(\n  inputOne: unknown,\n  inputTwo: unknown\n): boolean {\n  // Check primitives\n  if (Object.is(inputOne, inputTwo)) {\n    return true;\n  }\n\n  const typeOfValueOne = getType(inputOne);\n  const typeOfValueTwo = getType(inputTwo);\n\n  const bothObjects =\n    typeOfValueOne === 'object' && typeOfValueTwo === 'object';\n  const bothArrays = Array.isArray(inputOne) && Array.isArray(inputTwo);\n\n  if (!bothObjects && !bothArrays) {\n    return false;\n  }\n\n  // Compare the keys of arrays and objects.\n  if (\n    Object.keys(inputOne as Array<unknown> | Object).length !==\n    Object.keys(inputTwo as Array<unknown> | Object).length\n  ) {\n    return false;\n  }\n  for (const key in inputOne as Record<string, unknown>) {\n    if (!deepEqual((inputOne as any)[key], (inputTwo as any)[key])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n"
    }
  },
  {
    "name": "formatToCurrency",
    "dir": "utils",
    "file": {
      "name": "formatToCurrency.ts",
      "content": "interface CurrencyFormatOptions extends Intl.NumberFormatOptions {\n  locale?: string;\n}\n\n/**\n * Formats a number to a currency string based on the specified options.\n *\n * @param {number} amount - The number to be formatted.\n * @param {CurrencyFormatOptions} [options={}] - The options for formatting the currency.\n * @return {string | Error} - The formatted currency string or an Error if the amount is not a number.\n */\nexport default function formatToCurrency(\n  amount: number,\n  options: CurrencyFormatOptions = {}\n): string | Error {\n  if (typeof amount !== 'number' || Number.isNaN(amount)) {\n    throw new Error('Amount must be a number');\n  }\n\n  const { currency = 'USD', locale = 'en-US' } = options;\n\n  const formatter = new Intl.NumberFormat(locale, {\n    style: 'currency',\n    currency: currency,\n    ...options\n  });\n\n  return formatter.format(amount);\n}\n"
    }
  },
  {
    "name": "getType",
    "dir": "utils",
    "file": {
      "name": "getType.ts",
      "content": "// Inspiration - https://www.zhenghao.io/posts/js-data-type\n\n/**\n * Converts the first letter of a string to lowercase.\n *\n * @param {string} str - The input string.\n * @return {string} The modified string with the first letter in lowercase.\n */\nconst lowerCaseFirstLetter = (str: string): string =>\n  str[0].toLowerCase() + str.slice(1);\n\n/**\n * Returns the type of the provided input as a string.\n * For objects, it returns the specific type (e.g., 'array', 'date') in lowercase.\n *\n * @param {unknown} input - The input whose type is to be determined.\n * @returns {string} - The type of the object.\n */\nfunction getType(input: unknown): string {\n  if (input === null) {\n    return 'null';\n  }\n\n  const type = typeof input;\n  if (type !== 'object') {\n    return type;\n  }\n\n  return lowerCaseFirstLetter(\n    Object.prototype.toString.call(input).slice(8, -1)\n  );\n}\n\nexport default getType;\n"
    }
  },
  {
    "name": "mdxLoader",
    "dir": "utils",
    "file": {
      "name": "mdxLoader.ts",
      "content": "import fs from 'fs';\nimport path from 'path';\n\n/**\n * inspiration - https://github.com/leerob/leerob.io/blob/9566a4fe599a3a24b9264420ea2490f28e921887/app/db/blog.ts\n * MDX Utils: Load, Parse, and Extract Data from MDX Files\n *\n * This module provides functions to read, parse, and extract metadata and content\n * from Markdown with JSX (MDX) files.\n *\n * Key Features:\n * - Frontmatter Parsing: Extracts metadata from the YAML-like frontmatter block at the beginning of MDX files.\n * - MDX File Discovery: Finds all MDX files in a specified directory (or subdirectories).\n * - Data Extraction: Combines metadata, content, and filename-derived slugs for easy consumption.\n *\n * How to Use:\n *\n * 1. Installation (if not part of your project already):\n *\n *    npm install fs path\n *\n *\n * 2. Import the Functions:\n *\n *    import { getWritings } from './utils/mdxLoader'; // Adjust the path as needed\n *\n *\n * 3. Prepare MDX Files:\n *    - Create MDX files with frontmatter in a directory (e.g., 'blog').\n *    - Frontmatter should use YAML format, enclosed between '---' delimiters:\n *\n *      ---\n *      title: My Blog Post\n *      date: 2023-12-15\n *      tags: technology, webdev\n *      ---\n *\n *      This is the content of my blog post.\n *\n *\n * 4. Retrieve MDX Data:\n *\n *    const writings = getWritings('blog'); // Replace 'blog' with your directory\n *\n *    - `writings` will be an array of objects, each containing:\n *      - `slug`: Filename without extension (e.g., 'my-blog-post')\n *      - `metadata`: An object with frontmatter properties (e.g., `{ title: 'My Blog Post', date: '2023-12-15', tags: 'technology, webdev' }`)\n *      - `content`: The MDX content without frontmatter\n *\n * Advanced Usage:\n * - `getMDXData(dir)`: For more control, use this function to specify any directory path directly.\n * - `readMDXFile(filePath)`: Directly read and parse a single MDX file by its path.\n * - `parseFrontmatter(content)`: Extract metadata if you already have the MDX content.\n *\n * Note: This module uses synchronous file operations, which might not be ideal for large directories.\n */\n\n// define your metadata  types\ntype Metadata = Record<string, string | undefined>;\n\nexport function parseFrontmatter(fileContent: string) {\n  const frontmatterRegex = /---\\s*([\\s\\S]*?)\\s*---/;\n  const match = frontmatterRegex.exec(fileContent);\n  const frontMatterBlock = match![1];\n  const content = fileContent.replace(frontmatterRegex, '').trim();\n  const frontMatterLines = frontMatterBlock.trim().split('\\n');\n  const metadata: Partial<Metadata> = {};\n\n  frontMatterLines.forEach((line) => {\n    const [key, ...valueArr] = line.split(': ');\n    let value = valueArr.join(': ').trim();\n    value = value.replace(/^['\"](.*)['\"]$/, '$1');\n    metadata[key.trim() as keyof Metadata] = value;\n  });\n\n  return { metadata: metadata as Metadata, content };\n}\n\nexport function getMDXFiles(dir: fs.PathLike) {\n  return fs.readdirSync(dir).filter((file) => path.extname(file) === '.mdx');\n}\n\nexport function readMDXFile(filePath: fs.PathOrFileDescriptor) {\n  const rawContent = fs.readFileSync(filePath, 'utf-8');\n  return parseFrontmatter(rawContent);\n}\n\nexport function getMDXData(dir: string) {\n  const mdxFiles = getMDXFiles(dir);\n  return mdxFiles.map((file) => {\n    const content = readMDXFile(path.join(dir, file));\n\n    const slug = path.basename(file, path.extname(file));\n    return {\n      ...content,\n      slug\n    };\n  });\n}\n\n// name it as per your requirement\nexport function getWritings(dirName: string) {\n  return getMDXData(path.join(process.cwd(), dirName));\n}\n"
    }
  },
  {
    "name": "nFormatter",
    "dir": "utils",
    "file": {
      "name": "nFormatter.ts",
      "content": "interface NFormatterOptions {\n  digits?: number;\n  full?: boolean;\n}\n\n/**\n * Formats a number into a human-readable string with optional suffixes (K, M, B, etc.)\n * or in full numeric format.\n *\n * @param {number} num - The number to format.\n * @param {NFormatterOptions} [opts={ digits: 1 }] - The formatting options.\n * @param {number} [opts.digits=1] - The number of digits after the decimal point.\n * @param {boolean} [opts.full=false] - If true, formats the number with comma separators.\n * @returns {string} The formatted number as a string.\n * @throws {Error} If the input number is not a valid number.\n */\nexport function nFormatter(\n  num: number,\n  opts: NFormatterOptions = { digits: 1 }\n): string {\n  if (num === undefined || num === null) {\n    throw new Error('The number must be provided.');\n  }\n\n  if (typeof num !== 'number' || isNaN(num)) {\n    throw new Error('The input must be a valid number.');\n  }\n\n  if (opts.full) {\n    return Intl.NumberFormat('en-US').format(num);\n  }\n\n  const lookup = [\n    { value: 1, symbol: '' },\n    { value: 1e3, symbol: 'K' },\n    { value: 1e6, symbol: 'M' },\n    { value: 1e9, symbol: 'G' },\n    { value: 1e12, symbol: 'T' },\n    { value: 1e15, symbol: 'P' },\n    { value: 1e18, symbol: 'E' }\n  ];\n\n  const regex = /\\.0+$|(\\.[0-9]*[1-9])0+$/; // removes trailing zeroes\n\n  const item = lookup\n    .slice()\n    .reverse()\n    .find((item) => num >= item.value);\n\n  if (item) {\n    return (\n      (num / item.value).toFixed(opts.digits).replace(regex, '$1') + item.symbol\n    );\n  }\n\n  return '0'; // doesn't work for negative numbers\n}\n"
    }
  },
  {
    "name": "slugify",
    "dir": "utils",
    "file": {
      "name": "slugify.ts",
      "content": "/**\n * Slugifies a given text by converting it to lowercase, removing diacritics,\n * replacing non-alphanumeric characters with hyphens, and removing leading\n * and trailing hyphens.\n *\n * @param {string} text - The text to be slugified.\n * @return {string} The slugified version of the text.\n * @throws {Error} If the input is not a string.\n */\nfunction slugify(text: string): string {\n  if (typeof text !== 'string') {\n    throw new Error('Please provide a string');\n  }\n\n  let slug = text\n    .normalize('NFD') // Decompose combined characters (e.g., é → e + ´)\n    .replace(/[\\u0300-\\u036f]/g, ''); // Remove diacritics (e.g., ´)\n\n  slug = slug.toLowerCase().trim();\n\n  slug = slug.replace(/[^a-z0-9]+/g, '-'); // Allow only alphanumeric and hyphens\n  slug = slug.replace(/-+/g, '-'); // Replace multiple consecutive hyphens with one\n\n  slug = slug.replace(/^-+|-+$/g, ''); // Remove Leading/Trailing Hyphens\n\n  return slug;\n}\n\nexport default slugify;\n"
    }
  },
  {
    "name": "throttle",
    "dir": "utils",
    "file": {
      "name": "throttle.ts",
      "content": "type ThrottleOptions = {\n  leading?: boolean;\n  trailing?: boolean;\n};\n\ninterface ThrottledFunction extends Function {\n  cancel: () => void;\n  flush: () => void;\n}\n\n/**\n * Creates a throttled function that limits the rate at which it can be called.\n *\n * @param {Function} func - The function to be throttled.\n * @param {number} [wait=0] - The number of milliseconds to wait between each invocation of the function.\n * @param {ThrottleOptions} [options={}] - The options for the throttling behavior.\n * @param {boolean} [options.leading=true] -Specify invoking on the leading edge of the timeout.\n * @param {boolean} [options.trailing=true]  - Specify invoking on the trailing edge of the timeout.\n * @return {ThrottledFunction} - The throttled function with `cancel` and `flush` methods.\n */\n// eslint-disable-next-line no-unused-vars\nfunction throttle<T extends (...args: any[]) => any>(\n  func: T,\n  wait: number = 0,\n  options: ThrottleOptions = {}\n): ThrottledFunction {\n  let timeout: ReturnType<typeof setTimeout> | null = null;\n  let lastArgs: any = null;\n  let lastContext: any = null;\n  let lastInvokeTime = 0;\n  const { leading = true, trailing = true } = options;\n\n  function invokeFunc(time: number) {\n    lastInvokeTime = time;\n    func.apply(lastContext, lastArgs);\n    lastContext = null;\n    lastArgs = null;\n  }\n\n  function trailingEdge() {\n    if (trailing && lastArgs) {\n      invokeFunc(Date.now());\n    }\n    timeout = null;\n  }\n\n  function timerExpired() {\n    const time = Date.now();\n    if (time - lastInvokeTime >= wait) {\n      trailingEdge();\n    } else {\n      timeout = setTimeout(timerExpired, wait - (time - lastInvokeTime));\n    }\n  }\n\n  function throttled(this: any, ...args: Parameters<T>) {\n    const time = Date.now();\n    if (!lastInvokeTime && !leading) {\n      lastInvokeTime = time;\n    }\n\n    const remaining = wait - (time - lastInvokeTime);\n    lastArgs = args;\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    lastContext = this;\n\n    if (remaining <= 0 || remaining > wait) {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = null;\n      }\n      invokeFunc(time);\n    } else if (!timeout && trailing) {\n      timeout = setTimeout(timerExpired, remaining);\n    }\n  }\n\n  function cancel() {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    lastInvokeTime = 0;\n    lastArgs = null;\n    lastContext = null;\n    timeout = null;\n  }\n\n  function flush() {\n    if (timeout) {\n      invokeFunc(Date.now());\n      clearTimeout(timeout);\n      timeout = null;\n    }\n  }\n\n  throttled.cancel = cancel;\n\n  throttled.flush = flush;\n\n  return throttled;\n}\n\nexport default throttle;\n"
    }
  }
]